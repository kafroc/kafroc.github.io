---
layout: post
comments: true
title: 浅谈可信启动
category: 网络安全
keywords: Trusted boot,2020
---

本文主要从原理上介绍可信启动流程，从启动过程，可信启动原理，模拟可信启动三个过程展开说明

# 计算机启动过程简介

我将按两类设备的启动过程分开描述，分别是 x86/x86_64 平台设备的启动和嵌入式设备的启动

## x86/x86_64 平台设备的启动

x86 平台启动过程如下图所示

![](http://kafroc.github.io/assets/img/2020-05-17-01.png)

简略流程： cpu --> BIOS --> GRUB --> Kernel --> OS

## 嵌入式设备的启动

嵌入式平台启动过程如下图所示

![](http://kafroc.github.io/assets/img/2020-05-17-02.png)

简略流程： cpu --> u-boot --> Kernel --> OS

# 可信启动思路

可信启动的核心有两个，一个是可信根，另一个是可信链。

大家对 PKI 体系应该都有了解，可信启动的两个概念可类比与证书的可信，当我们访问一个 https 站点时，站点会把证书传送给客户端。客户端要去校验证书的合法性和有效性，就需要验证两点，第一点，该站点的根证书(CA)在客户端所在机器是否是可信的，第二点，从 CA 到站点证书的证书链是否是完整的。

要实现可信启动，首先需要 cpu 的支持，其次还需要 TPM（Trusted Platform Module）芯片的支持，TPM 有两个作用，作用一：提供加解密算法的支持，作用 2：存储对称密钥及私钥。可能部分嵌入式产品还需要 OTP（One Time Programmable）芯片。下面以嵌入式环境为例，说明可信启动的实现方式。

## 环境

支持可信启动的主芯片，OTP 芯片，Flash 芯片

假设 flash 芯片的分区结构如下
| u-boot | kernel | romfs | config |

u-boot 分区结构如下
| 4 字节：公钥长度 | 1024 字节：RSA 公钥 | 4 字节：u-boot 的 hash 签名长度 ｜ 1024 字节：u-boot 的 hash 签名 | 4 字节：u-boot 版本号 | 4 字节：u-boot 长度 | u-boot 内容 |

OTP 存储结构如下
｜ RSA 公钥的 sha256 值 ｜ u-boot 版本号 ｜

## 可信启动流程

启动设备，cpu 判断是否使能可信启动，如果是，则按照可信启动流程执行

第一步 读取公钥，并判断公钥的 hash 是否与 OTP 中的一致，如果不一致则退出启动流程（确认公钥的完整性）

第二步 读取 u-boot 内容，使用 sha256 对 u-boot 内容做 hash 运算，得到结果 A

第三步 读取 u-boot 的 hash 签名，使用第一步的公钥验签，得到结果 B

第四步 判断结果 A 和 结果 B 是否一致，如果不一致则退出启动流程（确认 u-boot 的完整性）

第五步 判断 u-boot 的版本是否大于等于 OTP 中的 u-boot 版本，如果不符合则退出启动流程（防止 u-boot 回退，刷回官方签名的带漏洞的旧版本）

第六步 u-boot 验证 kernel 的完整性

第七步 kernel 验证 romfs 的完整性

可信启动最关键的是从 cpu 到 bootloader 的过程，从 bootloader 开始到 kernel，到 romfs 等阶段都和前面的校验过程类似，

# 可信启动模拟实现

我用 python 写了一个可信启动从 cpu 到 u-boot 的模拟器，把我所理解的可信启动的过程呈现出来

模拟器文件结构如下

```
Kafrocs:Trusted Boot Emulate kafroc$ ls -R
CPU		Flash		OTP		power.py	vendor

./CPU:
cpu.config	cpu.py

./Flash:
config	kernel	romfs	uboot

./Flash/config:
config

./Flash/kernel:
kernel

./Flash/romfs:
romfs

./Flash/uboot:
RSA_Pub			uboot.py	uboot_Version	uboot_signature

./OTP:
RSA_Pub_Hash	u-boot_Version

./vendor:
prikey		pubkey		rsa-sig.py	uboot-partition

./vendor/uboot-partition:
RSA_Pub		uboot.py	uboot_Version	uboot_signature
```

其中 CPU Flash OTP power.py 模拟嵌入式设备，vendor 模拟设备制造厂商

模拟器的功能如下<br>
1 设备厂商进入 vendor 目录，可以编辑配置 uboot，并执行 python3 rsa-sig.py 生成相关文件<br>
把 vendor/uboot_signature 下的文件复制到 Flash/uboot/下面，模拟刷写固件的操作<br>
2 通过 CPU/cpu.config 来配置是否使能可信启动<br>
3 通过 python3 power.py On 来启动设备<br>
如果使能可信启动，在启动设备时，cpu 会按照**可信启动流程**执行，如果校验失败，则停止启动<br>
如果成功，则加载 uboot 执行

演示结果如下

```
Kafrocs:Trusted Boot Emulation kafroc$ python3 power.py On
system starting ...
Read RSA Public Key from Flash and Calculate the hash value
Read the hash of RSA Public Key in OTP
Verify RSA Public Key OK.
Calculate the sha256 of uboot
verify u-boot signature
uboot verify OK.
Check u-boot version ...
u-boot running ...
```

模拟器代码：[https://github.com/kafroc/Trusted-Boot-Emulation](https://github.com/kafroc/Trusted-Boot-Emulation)

**由于笔者水平有限，文章难免会有错误的，欢迎读者批评指正。笔者个人邮箱：kafrocyang@gmail.com**
